# Security Architecture Documentation

## Overview

This document describes the security architecture of the end-to-end encrypted chat application. The system implements a Signal Protocol-inspired encryption scheme using X3DH for key agreement and the Double Ratchet algorithm for message encryption.

## Table of Contents

1. [Cryptographic Primitives](#cryptographic-primitives)
2. [Key Exchange (X3DH)](#key-exchange-x3dh)
3. [Message Encryption (Double Ratchet)](#message-encryption-double-ratchet)
4. [Authentication](#authentication)
5. [Local Storage Encryption](#local-storage-encryption)
6. [Network Security](#network-security)
7. [Key Management](#key-management)
8. [Security Properties](#security-properties)

## Cryptographic Primitives

### Algorithms Used

#### Asymmetric Cryptography
- **Curve25519 (X25519)**: Elliptic curve Diffie-Hellman key exchange
  - Used for: DH ratchet, prekeys, ephemeral keys
  - Key size: 32 bytes
  - Provides ~128 bits of security

- **Ed25519**: Digital signatures (identity keys)
  - Used for: Long-term identity keys
  - Key size: 32 bytes
  - Fast signature verification

#### Symmetric Cryptography
- **AES-256-GCM**: Authenticated encryption
  - Used for: Message encryption, local storage encryption
  - Key size: 32 bytes (256 bits)
  - Nonce size: 12 bytes (96 bits)
  - Tag size: 16 bytes (128 bits)
  - Provides both confidentiality and authenticity

#### Key Derivation
- **HKDF-SHA256**: HMAC-based Key Derivation Function
  - Used for: Root KDF, chain KDF
  - Derives secure keys from shared secrets
  - Supports key separation and domain separation

- **PBKDF2-SHA256**: Password-based Key Derivation
  - Used for: Local storage encryption key
  - Iterations: 100,000
  - Protects against brute-force attacks on passwords

## Key Exchange (X3DH)

### Overview

X3DH (Extended Triple Diffie-Hellman) establishes a shared secret between two parties who have never communicated before. It provides:

- **Mutual authentication**: Both parties verify each other's identity
- **Forward secrecy**: Compromise of long-term keys doesn't compromise past sessions
- **Deniability**: No cryptographic proof of who sent a message
- **Asynchronous**: Recipient doesn't need to be online

### Key Types

1. **Identity Key (IK)**: Ed25519 long-term key
   - Generated once per user
   - Public key published to server
   - Used for authentication

2. **Signed Prekey (SPK)**: X25519 medium-term key
   - Rotated periodically (recommended: monthly)
   - Signed by identity key
   - Public key published to server

3. **One-Time Prekeys (OPK)**: X25519 single-use keys
   - Generated in batches (e.g., 100 keys)
   - Each used only once
   - Server removes after use
   - Replenished when supply is low

4. **Ephemeral Key (EK)**: X25519 temporary key
   - Generated by initiator for each session
   - Used only for this key exchange
   - Discarded after use

### X3DH Protocol Flow

#### Server-Side Storage

```
User A's Prekey Bundle:
├── Identity Key (IK_A)
├── Signed Prekey (SPK_A)
└── One-Time Prekeys [OPK_A1, OPK_A2, ...]
```

#### Initiator (Alice wants to message Bob)

1. **Fetch Bob's prekey bundle** from server:
   - IK_B (Bob's identity key)
   - SPK_B (Bob's signed prekey)
   - OPK_B (one of Bob's one-time prekeys, if available)

2. **Generate ephemeral keypair**: EK_A

3. **Perform Diffie-Hellman exchanges**:
   ```
   DH1 = DH(EK_A, SPK_B)
   DH2 = DH(EK_A, OPK_B)  // if OPK available
   ```

4. **Derive shared secret**:
   ```
   SK = KDF(DH1 || DH2)
   ```

5. **Send initial message** with:
   - EK_A (ephemeral public key)
   - Used OPK_B identifier
   - Encrypted message

#### Receiver (Bob receives message)

1. **Extract from message**:
   - EK_A (Alice's ephemeral key)
   - OPK identifier

2. **Perform same DH operations**:
   ```
   DH1 = DH(SPK_B, EK_A)
   DH2 = DH(OPK_B, EK_A)  // using identified OPK
   ```

3. **Derive same shared secret**:
   ```
   SK = KDF(DH1 || DH2)
   ```

4. **Delete used one-time prekey**

### Security Properties of X3DH

- **Forward Secrecy**: Compromise of long-term keys doesn't affect past sessions
- **Future Secrecy**: Can be achieved by rotating signed prekeys
- **Authentication**: Both parties authenticated via identity keys
- **Deniability**: No non-repudiable signatures on messages

## Message Encryption (Double Ratchet)

### Overview

The Double Ratchet algorithm provides end-to-end encryption with strong security properties. It combines two ratchets:

1. **DH Ratchet**: Performs a new Diffie-Hellman exchange with each message exchange
2. **Symmetric Ratchet**: Derives new encryption keys for each message

### Ratchet State

Each session maintains:

```python
{
    root_key: bytes,              # Current root key
    sending_chain_key: bytes,     # Chain key for sending
    receiving_chain_key: bytes,   # Chain key for receiving
    dh_private: bytes,            # Our current DH private key
    dh_public: bytes,             # Our current DH public key
    dh_remote_public: bytes,      # Their current DH public key
    send_count: int,              # Messages sent in current chain
    recv_count: int,              # Messages received in current chain
    skipped_keys: dict            # Stored keys for out-of-order messages
}
```

### Sending Messages

1. **Derive message key**:
   ```
   CK_send, MK = KDF_Chain(CK_send, "MessageKeys")
   ```

2. **Encrypt message**:
   ```
   ciphertext = AES-GCM(MK, plaintext, AD)
   ```

3. **Create header**:
   ```
   header = {
       dh_public: our_current_DH_public,
       prev_count: messages_in_previous_chain,
       msg_num: current_message_number
   }
   ```

4. **Increment counter**: `send_count++`

### Receiving Messages

1. **Check if DH ratchet step needed** (remote DH key changed):
   ```
   if header.dh_public != dh_remote_public:
       perform_dh_ratchet_step(header.dh_public)
   ```

2. **Skip message keys** (for out-of-order delivery):
   - Store skipped keys for later use
   - Maximum skip: 1000 messages (prevents DoS)

3. **Derive message key**:
   ```
   CK_recv, MK = KDF_Chain(CK_recv, "MessageKeys")
   ```

4. **Decrypt message**:
   ```
   plaintext = AES-GCM-decrypt(MK, ciphertext, AD)
   ```

5. **Increment counter**: `recv_count++`

### DH Ratchet Step

When receiving a message with a new DH public key:

1. **Derive new receiving chain**:
   ```
   dh_output = DH(our_DH_private, their_new_DH_public)
   RK, CK_recv = KDF_Root(RK, dh_output)
   ```

2. **Generate new DH keypair**

3. **Derive new sending chain**:
   ```
   dh_output = DH(our_new_DH_private, their_new_DH_public)
   RK, CK_send = KDF_Root(RK, dh_output)
   ```

### Security Properties of Double Ratchet

- **Forward Secrecy**: Past messages secure even if current keys compromised
- **Post-Compromise Security**: Security restored after compromise through DH ratchet
- **Message Unlinkability**: Messages can't be correlated
- **Out-of-Order Messages**: Handles network reordering
- **Immediate Key Updates**: New key for every message

## Authentication

### User Authentication (JWT)

- **Algorithm**: HS256 (HMAC-SHA256)
- **Token Lifetime**: 24 hours
- **Storage**: Client-side (memory/localStorage)
- **Claims**:
  ```json
  {
    "sub": "username",
    "exp": 1234567890
  }
  ```

### Session Authentication

- WebSocket connections authenticated with JWT
- Token verified on connection and message relay
- No authentication required for public key retrieval

## Local Storage Encryption

### Overview

All sensitive data stored locally is encrypted with a key derived from the user's password.

### Key Derivation

```python
salt = random(16 bytes)
storage_key = PBKDF2(
    password=user_password,
    salt=salt,
    iterations=100000,
    algorithm=SHA256,
    key_length=32
)
```

### Encrypted Data

1. **Message History**:
   - Plaintext messages encrypted with storage key
   - Stored in SQLite database
   - Includes: content, timestamp, direction, peer

2. **Session States**:
   - Double Ratchet state serialized to JSON
   - Encrypted with storage key
   - Allows session resumption

3. **Cryptographic Keys**:
   - Identity keys
   - Prekeys
   - All encrypted with storage key

### Storage Format

```
client_data/
├── username.db          # Encrypted SQLite database
└── username.salt        # PBKDF2 salt (not encrypted)
```

## Network Security

### Transport Layer

- **Production**: HTTPS/WSS (TLS 1.2+)
- **Development**: HTTP/WS (insecure, local only)
- Certificate pinning recommended for production

### Server Architecture

- **Zero-Knowledge**: Server never sees plaintext messages
- **No Message Storage**: Messages only relayed, not stored
- **Metadata**:
  - Server sees: sender, recipient, timestamp, message size
  - Server doesn't see: message content
  - Consider using Tor or VPN for metadata protection

### WebSocket Security

- Token-based authentication
- Per-message encryption
- Connection-level encryption (TLS)

## Key Management

### Client-Side Key Lifecycle

1. **Generation**:
   - Identity keys: Once per user
   - Prekeys: Batch of 10-100
   - Ephemeral keys: Per session
   - DH ratchet keys: Per message exchange

2. **Storage**:
   - Encrypted local storage
   - Never transmitted to server (except public keys)

3. **Rotation**:
   - Signed prekeys: Monthly (recommended)
   - One-time prekeys: Replenish when low
   - DH ratchet keys: Every message exchange

4. **Deletion**:
   - Used one-time prekeys: Immediately
   - Old DH keys: After ratchet step
   - Message keys: After use (except for skipped messages)

### Server-Side Key Management

- Stores only public keys
- Deletes used one-time prekeys
- No access to private keys or plaintext

## Security Properties

### End-to-End Encryption

- **Only communicating parties** can read messages
- Server acts as relay, cannot decrypt
- Man-in-the-middle requires compromising both endpoints

### Forward Secrecy

- Compromise of current keys doesn't compromise past messages
- New DH exchange with each conversation turn
- Message keys immediately deleted after use

### Post-Compromise Security (Future Secrecy)

- Security restored after key compromise
- DH ratchet introduces new entropy
- Recovery within one round-trip

### Deniability

- No cryptographic proof of message authorship
- Uses MAC, not signatures
- Both parties could have generated any message

### Authentication

- Identity keys provide long-term authentication
- Prevents impersonation
- TOFU (Trust On First Use) model

### Replay Protection

- Each message encrypted with unique key
- Nonces prevent replay within same session
- Message counters detect duplicates

## Limitations and Considerations

### Known Limitations

1. **Metadata Leakage**: Server sees communication patterns
2. **TOFU Model**: No built-in key verification (users should verify out-of-band)
3. **Web Client**: JavaScript crypto has limitations; CLI client preferred
4. **No Group Chat**: Current implementation is peer-to-peer only
5. **No Multi-Device**: Each device needs separate keys

### Security Assumptions

1. **Cryptographic Primitives**: Assumes AES-GCM, X25519, Ed25519 are secure
2. **Implementation**: Relies on cryptography library correctness
3. **Endpoint Security**: Assumes client devices are not compromised
4. **Server Honesty**: Assumes server correctly relays messages (doesn't provide fake keys)

### Recommendations

1. **Verify Identity Keys**: Out-of-band verification via QR code or key fingerprint
2. **Use Strong Passwords**: For local storage encryption
3. **Secure Endpoints**: Keep devices and software updated
4. **Use Tor/VPN**: For metadata protection
5. **Regular Key Rotation**: Rotate signed prekeys monthly
6. **Secure Deletion**: Overwrite keys in memory after use
7. **Code Auditing**: Independent security review recommended

## Compliance and Standards

### Cryptographic Standards

- NIST-approved algorithms (AES-256, SHA-256)
- Modern elliptic curves (Curve25519)
- Standard protocols (X3DH, Double Ratchet)

### Best Practices

- Constant-time operations to prevent timing attacks
- Authenticated encryption (AES-GCM)
- Secure random number generation
- Proper key derivation (HKDF, PBKDF2)

## References

- [Signal Protocol Specifications](https://signal.org/docs/)
- [X3DH Specification](https://signal.org/docs/specifications/x3dh/)
- [Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/)
- [NIST Cryptographic Standards](https://csrc.nist.gov/)
